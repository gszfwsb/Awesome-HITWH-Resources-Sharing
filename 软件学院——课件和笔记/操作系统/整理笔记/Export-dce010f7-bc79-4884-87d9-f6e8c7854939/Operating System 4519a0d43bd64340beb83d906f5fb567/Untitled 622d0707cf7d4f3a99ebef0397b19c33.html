<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>第三单元 进程</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="622d0707-cf7d-4f3a-99eb-ef0397b19c33" class="page sans"><header><img class="page-cover-image" src="https://www.notion.so/images/page-cover/gradients_2.png" style="object-position:center 19.999999999999996%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">📌</span></div><h1 class="page-title">第三单元 进程</h1></header><div class="page-body"><p id="b1b79fef-ef65-42fd-8cd3-07c8f173a015" class="block-color-gray">process</p><p id="d8414bde-57b5-4cd9-97f0-44f17653f2bf" class=""><strong>编译四过程：预处理、编译、汇编、链接</strong></p><ol id="f8f62e54-6c0c-48e6-a41e-74c2f03c164a" class="numbered-list" start="1"><li>预处理：把程序中用到的头文件库中的代码引入到程序中（inline），c.→i.</li></ol><ol id="d36fde7a-65e8-49f1-93cd-122b6356999d" class="numbered-list" start="2"><li>编译：转换为汇编语言文件，i. →s.</li></ol><ol id="c6abd2a6-9b27-4f7c-b08b-8f0174678c63" class="numbered-list" start="3"><li>汇编：得到机器语言，s. →o.</li></ol><ol id="aacf1a65-83fb-45c7-9367-383871345b13" class="numbered-list" start="4"><li>链接：得到可执行的目标文件，ELF 格式（Executable/Linkable File）</li></ol><h1 id="59a1ec47-b401-4190-a3f4-17672342f91b" class="">3.1 进程的概念</h1><h2 id="971a4430-aad2-442c-bf09-899fa454c040" class="">进程的概念</h2><hr id="522e26dd-6f16-403f-b825-4924a4ba543a"/><ol id="0faf195b-cae6-41f2-9a12-323f25479015" class="numbered-list" start="1"><li>定义：<ul id="298b43c3-4532-4a5f-82c3-a3c8da64624e" class="bulleted-list"><li>进程： 执行中的程序</li></ul><ul id="fdf840e6-0827-4f90-866b-19e19b90f017" class="bulleted-list"><li>执行： OS会执行程序、进程、<strong>任务</strong>或者<strong>作业</strong></li></ul><ul id="5ff54cf0-ac7f-4244-ae0d-a7268941fbd8" class="bulleted-list"><li>任务（Task）&amp;作业（job）：<strong>作业是任务的一个实例</strong>，任务是抽象的概念，作业是具体的概念。Task每隔一段时间就会执行一次，形成一个新的job</li></ul></li></ol><ol id="6a362645-bbc4-4049-bcde-bbf69c2a7104" class="numbered-list" start="2"><li>程序&amp;进程：<ul id="0a4ecc77-bac7-41d1-a4c5-4b384120d781" class="bulleted-list"><li>程序是<strong>被动</strong>的实体，进程是<strong>活动</strong>的实体。</li></ul><ul id="32b33670-917e-4eba-b72f-544eec90f467" class="bulleted-list"><li><mark class="highlight-red">当一个程序被载入内存中的时候，这个程序就变成了进程。</mark></li></ul><ul id="8e8a8cdb-b06f-4872-9a98-29928a2eab0b" class="bulleted-list"><li>进程是<strong>动态</strong>的，程序是<strong>静态</strong>的：程序是代码的有序集合，而进程是程序的执行；进程不可用在计算机之内进行迁移，而对应静态文件的程序可以</li></ul><ul id="83934214-5458-4e47-81ec-ab0ab85bb010" class="bulleted-list"><li>进程组成包括程序、数据和进程控制块，程序只是其中一个部分</li></ul><ul id="9061e246-9e4f-4a2b-bb83-3cf614fb7bb4" class="bulleted-list"><li>一个程序对应于多个进程；通过调用关系，一个进程可以包括多个程序</li></ul></li></ol><ol id="5cd03a98-857e-467e-aa67-259b3af67131" class="numbered-list" start="3"><li>进程的内容：<ul id="913b3b4d-14a5-4c59-a411-42583e8109da" class="bulleted-list"><li>栈：包含临时数据，函数参数、返回地址、局部变量 FILO</li></ul><ul id="c715fd38-9eaa-491f-a2c6-a58ff8437285" class="bulleted-list"><li>堆：进程运行期间动态分配内存 malloc</li></ul><ul id="47be6c9b-23da-4948-90b8-92431f12687f" class="bulleted-list"><li>数据段：全局变量</li></ul><ul id="868c9c94-1437-4590-93ab-dff7ac312e87" class="bulleted-list"><li>程序代码=代码段/文本段：通过程序计数器和处理器寄存器的内容表示当前活动</li></ul></li></ol><figure id="e0ec4966-5c3e-4b15-8ea6-e60408310fa2" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled.png"><img style="width:576px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled.png"/></a></figure><blockquote id="7c4538e5-eaa6-4ad3-be20-c7f079678ed1" class="">使用栈的原因：被调函数和调用者之间的参数传递和返回值传递使用栈结构最合适，递归调用时也是通过栈实现的。</blockquote><p id="a0c85b4b-b7fa-47f4-bf2b-52164a57a0e7" class="">3. 操作系统管理物理资源和逻辑资源：</p><ul id="7fd199bf-1062-4a4c-941b-375a24f7ed59" class="bulleted-list"><li>物理资源：处理器、内存、IO设备</li></ul><ul id="c7aee1ab-a122-4574-bd33-74767c94ad4e" class="bulleted-list"><li>逻辑资源：进程、虚拟内存、数据结构</li></ul><p id="dd2340be-c4b0-49ea-99c5-9c68182e8c96" class=""><mark class="highlight-red">操作系统是通过</mark><strong><mark class="highlight-red">控制表</mark></strong><mark class="highlight-red">对系统中的每个资源进行管理的，以此类比进程</mark></p><p id="e7db9312-88aa-4192-bbbf-da57c753ed49" class="">控制表：如进程表、内存表、IO设备、文件表等等</p><figure id="fe4b51b1-b43d-45bd-b74c-aec81d4de33a" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%201.png"><img style="width:664px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%201.png"/></a></figure><p id="608181e3-c869-48f6-83db-4f42d4d29345" class="">4. 进程的特征：<div class="indented"><ul id="456bbabf-ef42-4fd4-a787-5d1d47aa9bc2" class="bulleted-list"><li>动态性（最基本特征）</li></ul><ul id="6a6ca60f-cd33-42ca-a873-19331e11830a" class="bulleted-list"><li>并发性（多个进程实体能都同时运行）</li></ul><ul id="8f228ee9-70a6-4cb7-bf14-7bc1b1d73ebd" class="bulleted-list"><li>独立性（单独的进程实体可以独立运行、分配资源并且独立接收调度）</li></ul><ul id="f1010cae-ed2b-4f0f-b31d-ed81ad32fd34" class="bulleted-list"><li>异步性（不同进程之间可以相互独立运行）</li></ul></div></p><p id="985fb263-d937-4183-91d5-509f90e381b4" class="">
</p><h2 id="87e20491-8818-43a7-8b27-72ccf2c55998" class="">进程控制块 PCB</h2><h3 id="dfdfee9b-d71d-4367-9123-45eb9e5f3887" class="">PCB的定义</h3><ol id="1d9b033e-3ef7-4930-981a-99c45e32bdb9" class="numbered-list" start="1"><li>是一个专门的数据结构，OS用它来记录外部特征，描述进程的运动变化过程</li></ol><ol id="86f1f0f3-c81b-46f2-9374-6ba7d90711c6" class="numbered-list" start="2"><li>PCB是进程管理和控制的重要数据结构，创建进程的同时创建PCB，并且伴随该进程的运行全过程，直到进程的撤销</li></ol><ol id="be73ab58-474b-4a5d-a2d0-886e84560ad4" class="numbered-list" start="3"><li>PCB是OS感知进程的<strong>唯一标识</strong>，因为进程和PCB一一对应</li></ol><ol id="ea5f9b8d-1d39-48bc-a562-f75898d4407b" class="numbered-list" start="4"><li>PCB经常被OS访问，因此常驻内存</li></ol><p id="da35c33a-eb49-4fbe-b4fe-8bf074bf447a" class="">
</p><figure id="b716aa3c-c833-4260-af62-4c29078de6e8" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%202.png"><img style="width:240px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%202.png"/></a></figure><h3 id="d5d0dbe0-3107-4703-8efd-c596d7bb32c3" class="">PCB的内容</h3><ol id="90df1bbc-735e-4ba9-85c3-5f0f11da1e81" class="numbered-list" start="1"><li>进程ID：<ul id="f2c93a90-9da8-4106-80a4-ffc287134e53" class="bulleted-list"><li>PID，大部分操作系统是通过PID来唯一标识进程。<mark class="highlight-red">一次运行期间PID固定，之后可能就不一样了</mark></li></ul><ul id="d77811fc-5464-42b3-a618-a2bc4385e123" class="bulleted-list"><li>每个进程必须有的PID可以是字符串或数字，在进程创建的时候由系统赋予。<mark class="highlight-red">只有一直运行的程序PID才会不变</mark></li></ul></li></ol><ol id="73b6908f-432f-412e-9bbf-c44409752994" class="numbered-list" start="2"><li>进程状态：
新建、就绪、运行、阻塞、停止</li></ol><ol id="d84f5b8e-7063-42b2-b0cb-83f6272dbb2f" class="numbered-list" start="3"><li>程序计数器PC：
表示进程要进行的下一个指令的地址</li></ol><ol id="5053fb8e-6f37-4d4c-a61c-7c093325274b" class="numbered-list" start="4"><li>CPU寄存器：<ul id="a93df702-b597-4f11-8ed3-d2c244429d06" class="bulleted-list"><li>累加器、索引寄存器、栈顶指针、通用寄存器、条件码寄存器</li></ul><ul id="50892b0b-700b-456e-acd3-1febdb176faa" class="bulleted-list"><li>CPU现场保护区，当目前进程由于其他原因不能继续执行时从CPU退出，需要保存此时的CPU的各种状态信息</li></ul></li></ol><ol id="1bc38210-1165-4217-83c1-db83f2e8f7ce" class="numbered-list" start="5"><li>CPU调度信息：
进程的优先级、调度队列的指针和其他调度参数</li></ol><ol id="645d4390-e027-4682-ac15-b6a2c7ac2d34" class="numbered-list" start="6"><li>内存管理信息：
基地址、界限地址、页表、段表</li></ol><ol id="1b544bb9-5eed-4bb0-87d0-e48212f683ad" class="numbered-list" start="7"><li>记账信息：
CPU使用时间、时间界限、作业或进程的数量</li></ol><ol id="9d54beb6-691b-46df-8e9e-015808487113" class="numbered-list" start="8"><li>IO状态信息：
IO设备进程分配状态、打开文件表等</li></ol><figure id="32978a97-4659-4c90-87d9-60edb87aeac3" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%203.png"><img style="width:748px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%203.png"/></a></figure><h3 id="7d26d34a-1e57-4005-bbb4-21f4ca0fcfe9" class="">PCB的组织形式</h3><ol id="1d11f6f5-b3a4-48fc-92c8-02821db627a3" class="numbered-list" start="1"><li>PCB表：
OS把PCB组织到一起，并放在固定的内存区域，称为PCB表</li></ol><ol id="0c05f295-5516-4f3b-ad78-6c2366360dd7" class="numbered-list" start="2"><li>PCB表个数决定了系统中最多可以<strong>存在</strong>多少个进程，也就是<strong>系统并发度</strong></li></ol><ol id="1fcab681-6975-4b46-b83f-01ab7f1805bd" class="numbered-list" start="3"><li>PCB表的组织形式：<mark class="highlight-red">链表</mark>索引方式</li></ol><h3 id="53d0e709-b279-407f-aca6-bb301de4e935" class="">进程状态</h3><ol id="c842b4e4-62ff-4bc4-a41c-c370acc91045" class="numbered-list" start="1"><li>新建：
进程正在被创建，OS已经完成创建一个进程所必要的工作（构造进程标识符、创建管理进程所需要的表格）</li></ol><ol id="780bc8a7-4801-48b7-841c-623932a7ce08" class="numbered-list" start="2"><li>运行：
指令正在被执行</li></ol><ol id="389d69f8-692e-4357-8aaa-d36375e8234d" class="numbered-list" start="3"><li>等待（阻塞）：
进程等待某一个事件的发生(如IO完成)。给它CPU时间片也无法执行</li></ol><ol id="2718d9b0-0657-4d25-96b4-3959fcef5f4e" class="numbered-list" start="4"><li>就绪：
等待分配处理器，就绪的进程被存储在处理及<strong>调度队列</strong>中，<strong>一旦得到CPU就可以运行</strong></li></ol><ol id="7a962f8f-e305-4f4c-80de-eca7c5b644cf" class="numbered-list" start="5"><li>终止：
进程完成执行，不再具有执行资格。<mark class="highlight-orange_background">但是相关的表格和其他信息被辅助程序保留，当数据不再需要后才可以被删除。</mark></li></ol><figure id="e3f9645b-e1d3-403d-906e-ad9f6f2c8d74" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%204.png"><img style="width:672px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%204.png"/></a></figure><p id="754c34fc-2350-4a11-96d6-03b1146d2305" class="">例：scanf调用的时候，在阻塞状态等待用户输入，用户输入之后进入了就绪状态，等待调度</p><p id="f65bc50b-625d-46b1-90e2-7e40da2c5904" class="">
</p><p id="3435bbb1-19c0-4c65-a33e-2fa3132538d8" class=""><strong>进程之间的切换：空闲&amp;执行</strong></p><figure id="ab59c1e8-b557-42d5-bb5f-e3ba5e1dd02f" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%205.png"><img style="width:579px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%205.png"/></a></figure><p id="9afbff98-3e0d-41ed-9542-5bad249499fb" class=""><strong>进程之间是树形结构</strong></p><figure id="ed9b3bf4-1371-4482-a122-ef85a00fe1e5" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%206.png"><img style="width:732px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%206.png"/></a></figure><p id="18f5cace-5c3e-4653-b8b3-fa80490edb5c" class="">
</p><h1 id="1e9ad9bc-a789-4a78-bc63-30e2b1cb1320" class="">3.2 进程调度</h1><h2 id="b200ccc1-27da-404d-9948-628ef28b0e89" class="">进程调度队列</h2><ul id="2ce143ff-5269-4a1e-8b43-a4d0cb50a94e" class="bulleted-list"><li>多道程序的目的是让CPU的利用率达到最大。因此需要调度</li></ul><ul id="e22885e9-7c24-4919-b7a5-069b25cb758c" class="bulleted-list"><li>OS持有作业队列来表示所有进程的集合，作业队列包括<mark class="highlight-red">就绪队列和</mark><strong><mark class="highlight-red">一组</mark></strong><mark class="highlight-red">设备队列</mark>，进程可以在多个调度队列之间转换</li></ul><ul id="1056b73a-bab3-42c4-9a64-38b5f05b7901" class="block-color-teal_background bulleted-list"><li>CPU 在多个进程之间切换，需要从调度队列中选取进程（PCB）运行。</li></ul><ol id="d1707d85-e67e-44fe-90e5-0a1f76412b93" class="numbered-list" start="1"><li>就绪队列：
驻留在内存中的<strong>就绪</strong>并且等待运行的进程，等待分配CPU的进程，一般用链表来实现。</li></ol><ol id="f7f3ed65-1995-4dee-96e4-eae940d64940" class="numbered-list" start="2"><li>设备队列：
等待特定的IO设备的进程队列。</li></ol><p id="39d2adda-6aa9-4753-97c6-a79f2aef7624" class=""><strong>就绪队列和IO设备队列</strong></p><p id="eddc7f50-29d0-4808-a64b-0b6cb2cb63cf" class="">可以看出来了使用指针来实现。</p><figure id="b2ffafec-af8c-4efb-a120-cd68f8e1f8a2" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%207.png"><img style="width:576px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%207.png"/></a></figure><h2 id="26990a5d-7186-44c2-b291-f9eb4f52161a" class="">进程调度</h2><p id="176efbab-3fbc-42ee-aa68-e12c5c6f2789" class="">以下4种情况会进入就绪状态（running to ready）：</p><ul id="7a26a818-674c-4ac0-aae3-79119f8d0085" class="bulleted-list"><li>IO请求后，被放到IO队列中，IO操作完后进入就绪队列</li></ul><ul id="7ee75ea4-075d-4c6a-89a2-56f3cef48c19" class="bulleted-list"><li>时间片用完，被放到就绪队列中</li></ul><ul id="8794d930-ba3b-4063-a7f1-72e136e89720" class="bulleted-list"><li>创建子进程，等待子进程结束</li></ul><ul id="11e1f61e-e056-43ca-aab2-76b2f3e5bc3d" class="bulleted-list"><li>中断发生而强制释放CPU，被放回到就绪队列</li></ul><p id="059208e9-ef41-42a2-ace0-4e32f9befc79" class=""><strong>表示进程调度的队列图</strong></p><figure id="2f78c57e-dd4a-4273-9676-a1d47a5a1bbb" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%208.png"><img style="width:615px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%208.png"/></a></figure><h2 id="966d95f6-746b-4c98-9394-300f2d87e3ea" class="">调度程序</h2><ol id="e86db3d8-5635-4244-bd73-de6c8696701d" class="numbered-list" start="1"><li>长期调度程序（作业调度程序）<ul id="70693a8c-0b56-4044-8af6-5a2643de7b82" class="bulleted-list"><li>从存储设备的缓冲池中选择进程，并且装入就绪队列（<mark class="highlight-teal_background">内存</mark>）中等待执行（<strong>IO调度</strong>）</li></ul><ul id="3ea5a40e-2e42-4cbd-828a-689818e01d5e" class="bulleted-list"><li>需要组合调用IO型进程和CPU型进程，使CPU和IO设备能够处于一个合理的工作载荷之中</li></ul></li></ol><ol id="f7471b85-8fe5-4b92-9d8c-a76a02508434" class="numbered-list" start="2"><li>中期调度程序（分时系统）<ul id="044ca5b6-43ed-4e88-86cb-62dc2c96adb0" class="bulleted-list"><li>核心思想就是把进程从内存中移出去，提高效率，<strong>Swap in and Swap out</strong></li></ul><ul id="1f86e636-5d0f-49b2-aade-1a44aa4845e6" class="bulleted-list"><li>目的是为了缓存内存紧张的情况，把内存中处于阻塞状态的进程换到外存上，<mark class="highlight-teal_background">降低多道程序的道数，</mark>使得一些长期得不到运行的进程可以被响应。当运行条件满足时，这些挂起的进程被重新调入内存。</li></ul></li></ol><ol id="261b5228-938c-4a02-86f0-fde63e1a2cf4" class="numbered-list" start="3"><li>短期调度程序（<strong>CPU</strong>调度程序）<p id="f445d714-b3df-4666-913e-d9c9ec98ec92" class="">从就绪队列<mark class="highlight-teal_background">（内存）</mark>中，选择一个进程给它分配CPU</p></li></ol><p id="442ceb66-7e58-4e40-9fca-128c605e3d6a" class=""><mark class="highlight-red">主要区别：执行的频率不同</mark></p><p id="36b83f16-a59c-4cb9-a9be-612af7100020" class=""><strong>分时系统</strong></p><figure id="c70d3c2a-134a-46b9-a65d-b93efdf001f4" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%209.png"><img style="width:675px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%209.png"/></a></figure><p id="30061074-bd7f-4936-8bc1-17adda0ff849" class=""><strong>特点：</strong></p><ul id="98963658-67e4-47bd-9290-56f03bc2537a" class="bulleted-list"><li>短期调度切换的频率高</li></ul><ul id="7f9c5f03-5dc9-4185-9c2d-dc348bfb6a42" class="bulleted-list"><li>长期调度执行的速度稍慢</li></ul><ul id="339ad1ef-159b-44f6-a3bc-fd73b1b1c07f" class="block-color-red bulleted-list"><li>多道程序的道数=加载到内存的进程数目</li></ul><h2 id="75385348-cd5a-418a-867d-f41508b357b3" class="">上下文切换</h2><p id="65c88fe3-9877-4878-818a-6604a256934e" class="">当CPU从当前进程切换到另一个进程的时候，系统必须保存当前进程的相关信息，以备被切换的进程恢复运行</p><ul id="1aab00d2-391f-4242-ab97-ca636304225a" class="bulleted-list"><li>save state into PCB</li></ul><ul id="3cf26c6f-f9d9-48d2-ba43-cc3436efa549" class="bulleted-list"><li>reload state from PCB</li></ul><figure id="a13ffddf-7449-4eea-8472-b63a3996b867" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2010.png"><img style="width:624px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2010.png"/></a></figure><ol id="f7141bd6-00b1-4015-86f2-3528a541e1d9" class="numbered-list" start="1"><li>定义
将CPU切换到另一个进程需要保存当前进程的状态，并恢复另一个进程状态。（上述两件事情）</li></ol><ol id="472adaa1-b4e3-4b38-86ef-90dcc16c1c9f" class="numbered-list" start="2"><li>上下文切换的时间是<strong>额外的开销</strong>
这个时候系统不能做什么有用的工作</li></ol><ol id="9619b56b-fc45-4aa9-b96a-331e1a4614f7" class="numbered-list" start="3"><li>上下文切换依赖于
硬件支持（内存速度、寄存器数量、指令运行的时间、载入保存时间）</li></ol><ol id="ac176d87-53e5-409e-8e7f-4a307d9f329e" class="numbered-list" start="4"><li>提高上下文切换速度的方法：
提供多组寄存器集合，上下文切换只需要简单改变当前寄存器组的指针</li></ol><p id="a6df0b64-2250-4f4e-b438-87c92d0b24b7" class=""><strong>上下文切换的次数是衡量一个调度算法性能好坏的标准之一</strong>。（因为如果切换时CPU 啥
也干不了，所以如果切换次数过多，则耗时太长）</p><p id="850292b1-54ca-4e46-8147-3b803c08a7f3" class="">
</p><h1 id="97bd5780-1aa5-434a-b78a-f1dc3ff71c8d" class="">3.3 进程的操作</h1><h2 id="4db249f9-27f3-4c68-a02c-83533450dc38" class="">进程创建</h2><figure id="105bfb9d-905c-426b-805d-a0650891f5f3" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2011.png"><img style="width:763px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2011.png"/></a></figure><p id="63f41404-0706-43ba-8b0f-42c448a5689a" class="">OS根据PID识别系统中的进程，一个进程可以创建另一个新进程。父进程→子进程。</p><ol id="5c5aa6e6-3848-46b5-a2e4-64ff348e6c17" class="numbered-list" start="1"><li>创建时间：<ul id="d975e41d-c66b-4fb0-a331-8f9ed3463c5a" class="bulleted-list"><li>作业调度（长期调度）：
作业调度程序在作业队列中（存储设备缓冲池）选择一个进程进入就绪队列，即装入内存，需要对其分配必要的资源、创建进程并且插入就绪队列</li></ul><ul id="6aac7e12-4cdb-492f-8014-51a5d3f2f898" class="bulleted-list"><li>用户登录：
在分时系统中用户在终端键入登陆命令后，若被判定为合法用户，系统就会创建进程并且插入就绪队列</li></ul><ul id="8495d60f-6ae3-4fbd-a373-dc0a92b0b6b8" class="bulleted-list"><li>提供服务：
当一个用户向操作系统提出请求，OS就会专门建立一个进程来服务</li></ul><ul id="1f4c472f-5ba4-416b-b349-9960954b1b56" class="bulleted-list"><li>应用请求：
应用进程的需要，当一个应用程序在执行的过程中需要创建新的进程，以此来并行的执行一些任务</li></ul></li></ol><ol id="974b9cf1-5b52-4596-be42-c6c15b365aca" class="numbered-list" start="2"><li>进程创建选项：<ul id="fb2ef722-5c3f-4493-9f2a-4b3e6a5e3b0b" class="bulleted-list"><li>资源共享选项：<p id="09672214-4581-4baa-896b-4e711bb96833" class="">共享所有资源、共享部分资源、不共享资源</p></li></ul><ul id="b11fdad8-f48f-4bc2-bbae-cde9a54053f2" class="bulleted-list"><li>执行选项：<p id="8fd2f2cd-0923-49e6-962e-036975e4842a" class="">父子同时执行、父进程等待子进程结束</p></li></ul><ul id="f167a3d2-887a-4b61-99ef-c265ca571f8f" class="bulleted-list"><li>地址空间选项<p id="709051fd-1645-4b1a-8375-09bbe9286b8f" class="">子进程完全复制父进程内容、子进程覆盖父进程内存空间</p></li></ul></li></ol><p id="880fce70-da79-4bf4-99dd-9a7b5bc3d1f4" class=""><mark class="highlight-red">操作系统中的上帝进程是sched 它的PID是0</mark></p><p id="6ddbeadd-07ab-4116-bcd5-46d08522f6fd" class="">
</p><h2 id="1a63cf2a-3a10-481e-bc33-1278abce2f91" class="">进程载入和执行</h2><ol id="50c8949a-45a1-486d-8835-5b97bb7ed5be" class="numbered-list" start="1"><li>步骤4：<ul id="aac8f54e-0a84-453d-a7a2-7752e8b743ca" class="bulleted-list"><li>在系统内部创建PCB：
目前正在运行的程序为父进程，在父进程中调用fork()，即在父进程中创建了子进程</li></ul><ul id="9221b2b0-c67e-4d1a-b974-1206716e3932" class="bulleted-list"><li>分配内存</li></ul><ul id="01058825-5d0f-4663-83e4-d5738feb4c3a" class="bulleted-list"><li>载入可执行文件：
创建成功后，子进程调用exec()系统调用载入子进程想要运行的程序（二进制）</li></ul><ul id="b68ec7a4-04d8-40d9-80ac-ce094862125e" class="bulleted-list"><li>初始化程序</li></ul></li></ol><p id="eaf81c50-199d-459c-96ce-7bc7cee34567" class=""><strong>父子进程的PID不允许一样，因为PID是唯一标识</strong><div class="indented"><ul id="77af4895-6c16-445e-8b5d-dae218d8a655" class="bulleted-list"><li>利用fork()创建子程序，复制一份父进程一样的内存空间</li></ul><ul id="b6c67f55-6db3-463f-bb30-27f139ca255b" class="bulleted-list"><li>如果子进程不想和父进程一模一样，就调用exec()装入自己的程序信息。否则和父进程行为是一样的。</li></ul><figure id="619aa6cc-cee7-493c-af28-b8050d1026cd" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2012.png"><img style="width:864px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2012.png"/></a></figure></div></p><p id="08badd02-2c20-456f-a1a4-d371dc105408" class=""><strong>例子</strong><div class="indented"><figure id="209bc9af-49bc-4ffb-9894-a3bce86dc188" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2013.png"><img style="width:683px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2013.png"/></a></figure><figure id="753f7a9a-09fa-42a4-b082-96514ed69b8b" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2014.png"><img style="width:694px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2014.png"/></a></figure></div></p><p id="06e9fb95-dc44-4e9a-94d5-b50e8495f2cc" class="">Fork的返回值：</p><ol id="eb4a6c9f-5db4-427e-adfa-03ffdb58118e" class="numbered-list" start="1"><li>当从系统调用fork返回的时候，CPU在父进程中时，返回值为创建的子进程的进程号，&gt;0</li></ol><ol id="edd0c8dd-2710-4e8f-aad8-7d3b972702f0" class="numbered-list" start="2"><li>当从系统调用fork返回的时候，CPU在子进程中时，返回值为0</li></ol><ol id="b7e87ba5-ff57-4b18-9148-ee4812e18385" class="numbered-list" start="3"><li>当子进程创建失败时，返回值&lt;0</li></ol><blockquote id="60034b7c-56e3-492d-914f-9317943ad4c3" class="">如果父进程不<mark class="highlight-red">wait()</mark>子进程的结束，父子进程的执行次序是不一定的，这个要根据CPU的调度来实现，是不可以预测的</blockquote><p id="6f11333e-6cc5-4e32-b4e0-4a0711880afa" class="">
</p><figure id="2c9a5a74-e8fb-4a1f-abc3-45bc28a8042b" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2015.png"><img style="width:1313px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2015.png"/></a></figure><h2 id="a8787e66-b00d-41ad-a757-3c8563fc1eed" class="">进程终止</h2><ol id="a70b2c15-27bb-4a82-93a0-6742ea515d6b" class="numbered-list" start="1"><li>进程主动终止进程<p id="b3a42bc1-903f-4876-a136-e4240dd70d0b" class="">子进程完成最后语句并使用<strong>exit()系统调用</strong>，请求操作系统删除自身并终止运行：
这时，子进程可以通过父进程的wait()返回状态值给父进程。</p></li></ol><p id="d1f1b9d1-74f8-40fd-b8ac-03cd4f0fb494" class="">等待子进程终止的例子：<div class="indented"><figure id="98bfa7fa-331d-4c8e-b71e-32f0586fb863" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2016.png"><img style="width:717px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2016.png"/></a></figure></div></p><p id="380bf30d-90f7-4fcc-b99b-0a794116490e" class="">2. 父进程终止子进程
可以用<strong>abort()系统调用</strong>来终止子进程的运行。父进程终止子进程的原因：<div class="indented"><ul id="a5cc7f84-3094-4f19-b815-c2e09ae5e362" class="bulleted-list"><li>子进程使用了超过它分配的资源</li></ul><ul id="fde06121-0dd3-4df0-9d26-1c2dd8df04ab" class="bulleted-list"><li>分配给子进程的任务不再需要</li></ul><ul id="a2d56a2e-3b01-4be8-8c53-93f41940e28b" class="bulleted-list"><li>父进程终止导致子进程终止（父进程终止，OS不允许子进程继续运行运行）称为<strong>级联终止</strong></li></ul></div></p><p id="5c273c1c-9e13-4178-aa7c-3fe17a2f8d82" class="">3. <strong>僵尸进程:</strong></p><p id="84cb3ede-5602-42d8-891a-eeb4c878536d" class="block-color-red">进程终止的特殊情况。一个子进程结束，但它的父进程还没有等待它（调用wait（）/waitpid（）），即没有父进程的进程。（子进程比父进程先结束，而父进程又没有
回收子进程，释放子进程占用的资源，此时子进程将成为一个<mark class="highlight-yellow">僵尸进程</mark>。如果父进程先退出，
子进程被init 接管，子进程退出后init 会回收其占用的相关资源）</p><ul id="3eef0799-982b-4abd-bbc8-0376dae65afc" class="block-color-red bulleted-list"><li>不管父进程有无wait（），只要是<mark class="highlight-yellow">子进程进行完了但是父进程还没进行完</mark>，那么从子进程
结束到父进程结束的这段时间子进程就是僵尸进程。</li></ul><ul id="1c88aa04-88da-4786-b5fc-4ed6e8f5e96a" class="block-color-red bulleted-list"><li>如果父进程先进行完但是子进程还没完，那么子进程会被交给init（）上帝进程，此时子
进程叫孤儿进程</li></ul><h2 id="7f05ff3a-3c24-4c5b-a43a-8efb0aa98d71" class="block-color-gray_background">进程阻塞（略）</h2><ol id="2f08fae5-2c03-4069-bd14-0660d3126162" class="block-color-gray numbered-list" start="1"><li>一个处在运行状态的进程，因等待某个时间的发生而不能继续运行时，会调用<strong>阻塞原语，</strong>把进程置为阻塞状态，并转进程调度程序</li></ol><ol id="a63eaef3-de0e-4d40-ae81-1abb167359ad" class="block-color-gray numbered-list" start="2"><li>调用进程阻塞操作的是在进程处于运行状态下执行的，它的执行将引起等待某事件的队列的改变</li></ol><p id="b395d780-fe23-4bdc-b742-d42e0f477540" class="block-color-gray">
</p><h2 id="a0542e11-a758-40fe-b328-f3818d5917d5" class="block-color-gray_background">进程唤醒（略）</h2><ol id="b8840f8a-a4c9-48b9-9e87-73b8406cdfdb" class="block-color-gray numbered-list" start="1"><li>当进程锁等待的事件发生时，该进程被唤醒</li></ol><ol id="46ea9bbb-3dc3-42f3-826a-33028783d7c1" class="block-color-gray numbered-list" start="2"><li>唤醒一个进程有两种方法：<ul id="85719baf-b405-4505-8a9f-6d1ea93164b9" class="bulleted-list"><li>系统进程唤醒</li></ul><ul id="1eaf680c-6748-4ff9-8e2a-d55d7976d615" class="bulleted-list"><li>事件发生进程唤醒</li></ul><p id="3bf2371f-f859-4544-ba30-d944900867fe" class="">
</p></li></ol><h1 id="da410f95-2ea3-4e0d-b876-bf58db44952d" class="">3.4 进程通信</h1><h2 id="00ea3c41-844e-45a8-bad6-7ecea6a250d1" class="">定义</h2><p id="0c7d7b0a-6afe-44ec-92fa-8aef67d88727" class="">系统内并发运行的进程可以是相互独立或者协作工作</p><ol id="e06e938b-196f-4cb3-ad21-0eb556019265" class="numbered-list" start="1"><li>独立进程：
如果一个进程不能影响其他进程或不被其他进程所影响，那么该进程是<strong>独立</strong>的，即进程之间没有共享数据</li></ol><ol id="18387d00-77ef-4fd0-a0a9-31f9dd0033dd" class="numbered-list" start="2"><li>协作进程：
如果一个进程影响其他进程或被其他进程所影响，那么这个进程是<strong>协作</strong>的，进程之间有数据共享</li></ol><ol id="eea05818-497c-406a-8f47-1c12713f3c6a" class="numbered-list" start="3"><li>进程协作的理由<strong>4</strong>点：<strong>信息共享、提高运算速度、模块化、方便</strong></li></ol><h2 id="be35b7ec-beac-4e30-8afa-7c0818fcac91" class="">通信模型</h2><ul id="30be0d90-8c38-412f-9987-cb845a06b482" class="bulleted-list"><li>message passing 消息传递</li></ul><ul id="efa449de-3f90-4c48-a865-cbc6a5d064e1" class="bulleted-list"><li>shared memory 内存共享</li></ul><figure id="4fc57422-acbd-4aa2-86e3-b191f74ee2d2" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2017.png"><img style="width:624px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2017.png"/></a></figure><ul id="c1faf0fe-67d0-4267-8202-f60340819c63" class="bulleted-list"><li>消息传递3<ol id="8dbadc66-33cf-4e45-ae87-5ebf008baa2c" class="numbered-list" start="1"><li>适合传递数据少</li></ol><ol id="e07eecc1-720f-49c2-aa6e-95eeefe808bb" class="block-color-red numbered-list" start="2"><li><mark class="highlight-red">内核干涉</mark></li></ol><ol id="709912e8-ceb0-424b-b349-b2c0fd05ef64" class="numbered-list" start="3"><li>易于实现</li></ol></li></ul><ul id="107de1b0-1583-4bd1-9306-c7457655e00b" class="bulleted-list"><li>共享内存3<ol id="c3b36027-f8d4-4d59-bbbf-4013841dccae" class="numbered-list" start="1"><li>允许最快通信</li></ol><ol id="bbe2c6dd-ea90-45d3-9b58-81af2d8fac6b" class="block-color-red numbered-list" start="2"><li><mark class="highlight-red">无需内核</mark></li></ol><ol id="43de5b5d-a8e0-4dfe-8c7e-5df820e8c718" class="numbered-list" start="3"><li>比消息传递快</li></ol><p id="efae2799-2e15-4d87-8a82-cd32cfe42771" class="">
</p></li></ul><h2 id="55f0f4b1-a2a0-4c4d-a3ee-da1c4dd18bed" class="">共享内存系统</h2><ol id="4ae97576-8c6e-46d2-9a96-164c4b4a26d5" class="numbered-list" start="1"><li>系统环境</li></ol><ul id="5d8751aa-c399-46c7-8e5b-ba7aa7a7c76a" class="bulleted-list"><li>每个进程都有自己<mark class="highlight-red">受保护</mark>的内存地址空间</li></ul><ul id="e291a788-af20-453a-b355-7af5697dbcf2" class="bulleted-list"><li>通常操作系统会试图阻止一个进程访问另一个进程的内存地址空间</li></ul><p id="5458e4ad-568f-4569-9ad8-a4a0435053cb" class=""><mark class="highlight-red">为了实现共享内存、便于2个或多个进程之间的访问，应该</mark><strong><mark class="highlight-red">取消上述限制</mark></strong><mark class="highlight-red">。</mark></p><p id="0a414101-c8ae-4314-9aed-83c02454151a" class=""><mark class="highlight-red">应该保障不能有2个以上的进程同时向共享区域写入数据，因此需要一个</mark><strong><mark class="highlight-red">同步</mark></strong><mark class="highlight-red">的机制。</mark></p><p id="9a97a98a-9384-47d4-99a4-96c14d07ba09" class="">2. 生产者-消费者问题</p><p id="6d93952b-5679-46d4-8fcf-8c22e5b355c9" class="">为了允许生产者和消费者进程能够并发运行，必须设置一个缓冲区被生产者和消费者所使用，<strong>即共享内存区域，</strong>实现方式如下</p><ul id="796eda6e-c6e6-4788-8ca1-11fbf2569d9d" class="bulleted-list"><li>无限缓冲：对于缓冲的大小没有限制
若缓冲为空，消费者必须要等待，生产者总是可以产生新的信息。</li></ul><ul id="fb871242-c67b-4aa9-b540-897d7d8c65b8" class="bulleted-list"><li>有限缓冲：缓冲大小固定
若缓冲为空，消费者必须等待；
若缓冲为满，生产者不能产生新的信息。</li></ul><p id="d279bc5e-8c5f-424a-ba26-3634c97c62c0" class=""><strong>有限缓冲</strong></p><figure id="187cdad1-9cc0-45e8-aeef-8bc709b35cc0" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2018.png"><img style="width:744px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2018.png"/></a></figure><blockquote id="ff4bf74a-17d0-4a18-bc84-a990ff7c2b23" class="">这里只能使用buffer_size-1位，否则如果 in%BUFFER_SIZE == out，初始状态和满状态没有办法区分。</blockquote><figure id="9a1fb4e0-f8b2-4bcc-81d2-d66d768a9484" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2019.png"><img style="width:943px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2019.png"/></a></figure><figure id="94450c42-9b50-45f6-9df8-961333fee93d" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2020.png"><img style="width:917px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2020.png"/></a></figure><p id="2b860a6d-cc49-4221-8e27-fa9d503664c0" class="">
</p><h2 id="02499f04-094e-45db-ace7-a2db4586bb3e" class="">消息传递</h2><ul id="0a578c8c-68da-46ab-849b-88f9e4ffb2ab" class="bulleted-list"><li>消息传递功能提供了两种操作：发送消息和接收消息。而且消息可以是定长或者变长的。<ul id="f230ae06-9438-4473-a66b-f2cdf766f5d2" class="bulleted-list"><li>发送：send(message)</li></ul><ul id="bc7b77ba-71a3-42c4-8dff-043b62b8eded" class="bulleted-list"><li>接收：receive(message)</li></ul></li></ul><ul id="64bb94cb-acf9-4bb2-b4f2-7657d191c0fc" class="bulleted-list"><li>假设进程P Q之间需要通信，首先需要建立<strong>通信线路</strong>，并且相互发送消息和接收消息。</li></ul><ul id="370f891d-1733-45e6-b665-e93fd93f7d39" class="bulleted-list"><li>通信线路的建立及实现方法<ul id="6289f39f-282a-45b7-a2d9-f042a5028f60" class="bulleted-list"><li>直接，间接 </li></ul><ul id="c891a2d1-3fa6-4f61-b068-709dbf18cd0d" class="bulleted-list"><li>同步，异步</li></ul><ul id="be651a66-421e-44a3-9e16-4e45c6e1910b" class="bulleted-list"><li>自动，显式缓冲</li></ul><p id="88986985-7ce6-4d2b-9990-365e4077aa9a" class="">
</p></li></ul><h3 id="95b896cd-5f63-4f32-9eb1-f59a114a48b6" class="">直接通信</h3><ul id="142dd08b-258e-47c8-8b93-5f4aed083756" class="bulleted-list"><li>需要通信的每个进程<mark class="highlight-red">必须明确命名通信的接收者和发送者</mark></li></ul><ul id="5fe1b083-d564-4617-9591-a25ec2bfc91e" class="bulleted-list"><li>通信线路的属性：<ul id="9161ba34-0fbe-491c-83f9-63f0b48835bf" class="bulleted-list"><li>线路是<strong>自动建立</strong>的</li></ul><ul id="9b2be65e-31f2-4406-9577-99a8fc19e631" class="bulleted-list"><li>一个线路只和2个进程相关，2个进程之间只有一个线路</li></ul><ul id="f9009c85-012c-4b99-9fba-1561d078b50a" class="bulleted-list"><li>连线可以无向，但是通常双向</li></ul></li></ul><ol id="7e3bc0e4-6bae-4d33-8e2e-2fdbc4faf1d0" class="numbered-list" start="1"><li>对称寻址（1对1）<ol id="ce19fde5-ada4-41a7-b1c9-69cea776ce0a" class="numbered-list" start="1"><li>send(P,message): 向进程P发送消息</li></ol><ol id="149b3fd6-24e7-4f15-a0cb-e895b19021aa" class="numbered-list" start="2"><li>receive(Q,message): 接收进程Q发来的消息
<mark class="highlight-blue">通信线路的属性：线路</mark><strong><mark class="highlight-blue">自动建立</mark></strong><mark class="highlight-blue">，一个线路只和</mark><strong><mark class="highlight-blue">两个进程</mark></strong><mark class="highlight-blue">相关，两个进程之间只有</mark><strong><mark class="highlight-blue">一个线路</mark></strong><mark class="highlight-blue">。</mark></li></ol></li></ol><ol id="473c416a-3ddd-485a-a001-166fb6d18573" class="numbered-list" start="2"><li>非对称寻址：接收者不需要命名发送者（多对一）<ol id="964b0a8f-a47d-44f8-aa60-93a4dd154a50" class="numbered-list" start="1"><li>send(P,message)</li></ol><ol id="e1462312-01f0-4cb8-a981-02d484ba9c61" class="numbered-list" start="2"><li>receive(id,message): 接收任何进程发送的消息</li></ol></li></ol><p id="e0b808c3-ff89-4fbf-b026-d935afa6fcae" class="">
</p><h3 id="134a65ef-5bf2-4d1e-a1e3-e5fef1eb589d" class="">间接通信</h3><ul id="5441a3cc-1d02-4a79-a5c3-70355391ebd3" class="bulleted-list"><li>通过<strong>端口</strong>或者<strong>邮箱</strong>来发送或者接收消息</li></ul><ul id="0cb19d55-0e71-4eda-89e1-eb56ccb7c1e0" class="bulleted-list"><li>每个邮箱都有一个唯一的标识符，进程之间可以通过共享端口来进行通信</li></ul><ul id="1a333276-d218-4850-9676-7a86eeb7f895" class="block-color-blue bulleted-list"><li>通信线路具有以下属性<ol id="d2b4fbae-55f8-4b82-802e-2cc21da16941" class="numbered-list" start="1"><li>两个进程共享一个邮箱（端口）就可以建立通信线路</li></ol><ol id="673f03a9-50ac-4472-8464-7a270e2dc40a" class="numbered-list" start="2"><li>一个线路（端口）可以与多个进程相关联</li></ol><ol id="c7864dcb-8550-4528-8d67-8b5d28ee4f06" class="numbered-list" start="3"><li>两个通信进程之间可以有多个通信线路，每个线路对应一个邮箱（端口）</li></ol><figure id="0653f4e8-31c4-4bd2-9882-a792b2341d7d" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2021.png"><img style="width:471px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2021.png"/></a></figure></li></ul><ul id="470a7b0d-17d1-4e3c-a21c-58add4252cc8" class="bulleted-list"><li>操作系统拥有的邮箱是独立存在的，操作系统必须提供机制来允许进程进行如下操作：<ol id="bbc4b23f-fb4e-49e0-b2f4-b3d1a6c8741e" class="numbered-list" start="1"><li>创建，删除邮箱</li></ol><ol id="1c87642f-a44c-4966-baa8-c32d11a78b4f" class="numbered-list" start="2"><li>通过邮箱发送，接收消息</li></ol></li></ul><ul id="edbd472e-3b7c-471d-8304-cd49504adf1c" class="bulleted-list"><li>世界标准邮箱，（WEB用80端口，FTP用21端口，Telnet用23端口）</li></ul><blockquote id="5eeb5f75-284e-41fe-b925-265f6a6b7539" class=""><strong>出现的问题：</strong>
当有三个进程共享一个端口时，进程A给端口发送消息，进程B C负责接收，此时消息的实际接收者是不确定的，即多进程作为消息接收者共享端口，导致了信息接收的不确定性。</blockquote><p id="e29b172c-ec2e-4504-95b6-42526dec91ef" class=""><strong>解决方案：</strong></p><ul id="7a1a918e-6e61-4570-aa76-c25e8a31c247" class="bulleted-list"><li>允许一个连接同时最多和两个进程相关</li></ul><ul id="cd2c07d4-409d-48a7-aa56-5b15ba86d955" class="bulleted-list"><li>只允许一个时刻有一个进程执行接收操作</li></ul><ul id="6fc162f6-743a-4f4d-b8a5-20927f4a7114" class="bulleted-list"><li>允许系统任意的选择接收者，同时通知给发送者实际接收者是谁</li></ul><p id="9a2f0f39-7fa1-48a9-bc3b-1d1e06f54a51" class="">
</p><h3 id="7d3bf1b7-fb41-49fd-bf77-6e4d463c8f8a" class="">同步和异步通信</h3><ul id="5e371f7a-3f7a-4047-8a5d-18663eab132d" class="bulleted-list"><li>同步=阻塞，异步=非阻塞</li></ul><ul id="443df056-0527-43f4-bd6a-6c4d7afd4678" class="bulleted-list"><li>发送和接收类型<p id="9c7a3e2a-794e-47b0-9b6e-d25d1055f450" class=""><strong>发送者：</strong></p><ol id="1bd3eb99-9130-4a1e-be0e-eee6fc7c9545" class="numbered-list" start="1"><li>阻塞发送：发送进程阻塞，直到被对方进程接收</li></ol><ol id="201c8faf-5c6a-4d18-8043-635a43e6d558" class="numbered-list" start="2"><li>非阻塞发送：发送进程发送消息并继续操作</li></ol><p id="c2b7ddfe-471b-472b-91d4-53dabfbe180e" class=""><strong>接收者：</strong></p><ol id="65a761fa-417f-4f64-ba48-4d3ab242f7c5" class="numbered-list" start="1"><li>阻塞接收：接收者阻塞，直到消息可用</li></ol><ol id="10ee26a2-12e2-4492-8fb4-c9c3fb1e95e5" class="numbered-list" start="2"><li>非阻塞接收：接收者收到一个有效消息或空消息</li></ol></li></ul><p id="828688fc-7328-4714-9063-3d5248a2d060" class="">
</p><figure id="dce0ae24-9c75-4b45-b0e5-86a6f9d86b20" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2022.png"><img style="width:1329px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2022.png"/></a></figure><h2 id="b1bc2465-a537-420f-aaaf-27062d837040" class="">缓冲</h2><figure id="5500cec9-42c2-411f-991f-9f83d316c513" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2023.png"><img style="width:732px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2023.png"/></a></figure><p id="bd02fe05-ce87-4e19-a5bb-143ec104f85f" class="">消息队列的实现方式：</p><ol id="d32db11d-53fa-4d44-a63a-266d5f20ae21" class="numbered-list" start="1"><li>零容量：队列的最大长度是0，没有等待的消息，阻塞。</li></ol><ol id="dc0eb05e-bb29-4355-ae0c-0e17ffb53ae5" class="numbered-list" start="2"><li>有限容量：队列长度有限，如果线路满，发送者必须等待，直到队列中的空间可以用为止。</li></ol><ol id="c3cb3472-dcaa-437b-b978-af819876d634" class="numbered-list" start="3"><li>无限容量：队列长度无限，不管多少消息在等待，从不阻塞发送者，即发送者不必等待。</li></ol><p id="79edd51c-6c05-4947-8e4b-58009019ccd6" class="">
</p><p id="b63204ff-6ae0-47c2-b75c-7cf3183336ed" class="">
</p><h1 id="0e8de294-c5a6-483c-8fb7-88890dfac245" class="">3.5 客户机-服务器系统通信</h1><h2 id="52775d83-a398-4560-abb6-b4dedc113271" class="">Sockets</h2><ul id="81f551fa-cc0d-4b91-a783-3d226640db65" class="bulleted-list"><li>socket被定义为通信的端点</li></ul><ul id="2c653a52-a6c2-431c-8d58-816504541c48" class="bulleted-list"><li>socket由IP地址和端口号连接组成</li></ul><ul id="924bae3a-12d0-4cbd-8f81-d1d49dafe3a5" class="bulleted-list"><li>连接由一对socket组成</li></ul><h3 id="4238f7fc-1b9d-438b-9f44-910b8032fa00" class="">Socket通信</h3><ol id="c1402cae-2dc3-40dc-9a92-3dd339125434" class="numbered-list" start="1"><li>面向连接socket：TCP socket 传递双方语言一致</li></ol><ol id="5a09fb3d-63d0-4773-a149-d5c06eb5e15e" class="numbered-list" start="2"><li>无连接socket：UDP socket 传递双方语言不一致<figure id="4fdfdae2-5a03-47db-9c34-9ee28a82ac15" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2024.png"><img style="width:469px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2024.png"/></a></figure></li></ol><ul id="269da6fc-a55e-46f6-a44b-97ead868deec" class="bulleted-list"><li>TCP是三次握手机制，服务器和客户机之间是全互锁通信的</li></ul><ul id="4f1b65b9-dd5d-4f65-910b-b7317f7dbe2b" class="bulleted-list"><li>UDP是不互锁机制，适合多媒体通信，丢几个包也不影响视频</li></ul><h2 id="7c133c55-4111-4561-beb5-c429864f83ec" class="">远程过程调用 RPC</h2><ul id="532f43a3-9e99-415d-9827-0745bfb66901" class="bulleted-list"><li>RPC抽象化了通过网络连接的进程之间的过程调用</li></ul><ul id="179dc8a6-78d2-48bd-bf00-03c6707480c7" class="block-color-red bulleted-list"><li>存根：远程过程的代理，隐藏通信细节<p id="03fa4a2f-8624-4631-afa6-5b8153a14543" class="block-color-red"><mark class="highlight-red">每个独立的远程过程都有一个存根</mark></p></li></ul><ul id="7db0b338-d8d1-43b0-a1a6-f27ed6c70896" class="bulleted-list"><li>客户机调用位于远程主机上的过程时，<ol id="c57afe1a-d29e-447f-abda-3aa60ebb16be" class="numbered-list" start="1"><li>客户端存根编组参数，向服务器相应存根发送参数</li></ol><ol id="334030e9-24c5-484f-88b6-a40da949cac1" class="numbered-list" start="2"><li>服务器存根接收参数，解组参数，调用响应过程。</li></ol><figure id="df1df155-3556-45f7-ac12-2e4a2744896a" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2025.png"><img style="width:580px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2025.png"/></a></figure><figure id="8d3ae1b5-b7cb-45b4-a0ae-f9d6aa39fa2c" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2026.png"><img style="width:722px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2026.png"/></a></figure><h2 id="ec1f71d3-7408-4dc8-91d7-4449cf03530d" class="">远程方法调用</h2><p id="291959f0-9533-4fe6-ae89-88d179581eec" class="">RMI类似于远程过程调用，是RPC的<strong>Java特性</strong></p><p id="517b2530-1033-4b9e-bef9-78198c1f0b6f" class=""><strong>与RPC的不同</strong></p><ul id="8923532f-a728-461e-8b4e-13617df152cc" class="bulleted-list"><li>RPC调用远程<mark class="highlight-red">子程序或函数</mark>，RMI调用远程<mark class="highlight-red">对象的方法</mark></li></ul><ul id="7fb55690-4b30-42c2-af94-5ba3a4a2adc7" class="bulleted-list"><li>RPC参数传递方式是<mark class="highlight-red">普通数据结构</mark>,RMI参数传递方式是<mark class="highlight-red">对象</mark><figure id="7eab326b-3be9-4805-a3cf-aba0251abb21" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2027.png"><img style="width:470px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2027.png"/></a></figure><figure id="5906d26b-bc2a-4e6b-8616-2c547559039d" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2028.png"><img style="width:615px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2028.png"/></a></figure></li></ul><h2 id="a149379b-2e6a-4ba5-9221-95f45ffe908a" class="">管道</h2><ul id="61511d5b-723e-4b7a-8c3c-7c399dd2e43e" class="bulleted-list"><li>进程之间进行通信的另一种方式，<mark class="highlight-red">管道通信方式的中间介质是文件</mark>，通常称这种文件为管道文件</li></ul><ul id="024afe17-4446-4f4b-b776-07e244f6996c" class="bulleted-list"><li>如两个进程利用管道文件进行通信时，一个进程为<strong>写进程</strong>，另一个进程为<strong>读进程</strong></li></ul><ul id="6f4b992d-aac9-4694-bf86-9919aeaf8e1a" class="bulleted-list"><li>提供进程<strong>同步</strong>运行，<mark class="highlight-red">适用于一个系统内部</mark></li></ul><ul id="de435d11-5892-4d14-a0e2-26ebf1a44e30" class="bulleted-list"><li>管道分为匿名管道和命名管道<ol id="e4dc11f7-72da-4280-b973-1547940457b3" class="numbered-list" start="1"><li>匿名管道<p id="9ece5544-cc06-44c1-9925-e29deb4df8d7" class="">管道是半双工的，数据只能够<mark class="highlight-red">单向通信</mark>；需要双方通信时，需要建立起两个管道；只能用于<mark class="highlight-red">父子进程或者兄弟进程</mark>之间（具有亲缘关系的进程）</p></li></ol><ol id="a6aca686-2322-4f74-95ac-82cd41eb653b" class="numbered-list" start="2"><li>命名管道<p id="2f2a977f-434f-4684-9549-1eefec6ea066" class="">可在同一台计算机的不同进程之间或者在跨越一个网络的不同计算机的不同进程之间，支持可靠、单向或者双向的数据通信</p></li></ol><figure id="f239bade-2141-4463-86b1-19338a9690fb" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2029.png"><img style="width:754px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2029.png"/></a></figure><p id="f8c1240b-440c-44aa-9102-1e8e65dec0ff" class="">3. 管道的实现：<div class="indented"><ul id="82747b66-8fbb-4c27-b190-0d501b5c99d7" class="bulleted-list"><li>FIFO</li></ul><figure id="f5dfa87a-a620-46bd-a6d0-30d7dbb81fdd" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2030.png"><img style="width:706px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2030.png"/></a></figure><ul id="22cf8a1e-07a2-40c3-905c-899503360ea1" class="bulleted-list"><li>多输入：</li></ul><figure id="a96ce9ce-b227-4f7d-8e1e-f449a5fcd959" class="image"><a href="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2031.png"><img style="width:624px" src="Untitled%20622d0707cf7d4f3a99ebef0397b19c33/Untitled%2031.png"/></a></figure><p id="98e05933-85c3-4dff-b45a-804cb4e33e06" class="">
</p></div></p></li></ul></li></ul></div></article></body></html>