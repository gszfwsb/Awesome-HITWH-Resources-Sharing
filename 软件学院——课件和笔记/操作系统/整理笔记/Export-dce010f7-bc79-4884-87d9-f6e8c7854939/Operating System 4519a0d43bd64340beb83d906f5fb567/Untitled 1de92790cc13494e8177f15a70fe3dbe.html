<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>第八章 内存管理</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="1de92790-cc13-494e-8177-f15a70fe3dbe" class="page sans"><header><img class="page-cover-image" src="https://www.notion.so/images/page-cover/woodcuts_15.jpg" style="object-position:center 30.000000000000004%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">📌</span></div><h1 class="page-title">第八章 内存管理</h1></header><div class="page-body"><h1 id="a31c3474-1993-4c24-be82-ec07bd39733c" class="">一、内存地址编址方式</h1><h2 id="14237477-9d60-400f-9e0a-939f824c5594" class="">进程使用内存空间的界定</h2><p id="abc68e18-2b2d-4fe3-9434-93a1b778502e" class="">为了运行程序，必须把程序从磁盘载入到内存。内存和寄存器是CPU唯一能直接访问的存储器</p><figure id="e912b0c8-75b9-4be1-b3f1-99dce0095a24" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled.png"><img style="width:709px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled.png"/></a></figure><ol id="637e87b3-e387-4ea5-9415-48d59a569fb5" class="numbered-list" start="1"><li>进程使用内存空间的界定。为了确保进程只访问合法地址范围，一个进程使用的内存地址范围是由一堆<mark class="highlight-red">基地址寄存器</mark>和<mark class="highlight-red">界限地址寄存器</mark>来定义的</li></ol><ol id="d8afce1c-33b6-49a9-9423-d9815654aa10" class="numbered-list" start="2"><li>为了确保进程正常运行必须保护内存,确保系统区域不被用户进程访问，确保用户进程不被其他进程访问</li></ol><h2 id="ebc917df-ecc3-499d-8189-0f10d77af9c5" class="">地址绑定</h2><p id="7306fd66-93a8-4d81-ac87-cb2a83774b4d" class="">地址绑定是<mark class="highlight-red">逻辑地址</mark>到<mark class="highlight-red">物理地址</mark>的映射</p><ol id="2ee7846c-9717-4abf-b84b-ada215089e30" class="numbered-list" start="1"><li>逻辑地址<ul id="1cc7d4dd-a44e-447c-9b2e-4578ad7dca28" class="bulleted-list"><li>也叫相对地址，用户程序在经过编译后形成的目标代码，其首地址一般为0，其余指令中的地址都是相对于首地址来编址。</li></ul><ul id="a922f5f5-f5c4-4a8f-8b96-d907d20482bc" class="block-color-red bulleted-list"><li>不能用逻辑地址<mark class="highlight-red">直接寻址</mark></li></ul><figure id="a3957954-9887-4fae-a3db-0d24541df23d" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%201.png"><img style="width:1179px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%201.png"/></a></figure><p id="3d382454-9c19-4fc0-8f58-18a39567bf15" class="">六列的内容：</p><ol id="8be18f8e-2bc7-44b0-a6a9-22437a965c5e" class="numbered-list" start="1"><li>地址：库在进程里地址范围</li></ol><ol id="521c4030-f96c-4b22-9ea5-8ea2188f604e" class="numbered-list" start="2"><li>权限：虚拟内存的权限，r=读, w=写, x=可运行, s=共享, p=私有；</li></ol><ol id="15e2cd63-528d-4427-8c83-dd9896ac86bf" class="numbered-list" start="3"><li>偏移量：库在进程里地址范围</li></ol><ol id="ccbd065e-b43a-43db-8828-4f069d3da796" class="numbered-list" start="4"><li>设备：映像文件的主设备号和次设备号；</li></ol><ol id="4118a0f3-db50-44c6-be84-ae84f38f981b" class="numbered-list" start="5"><li>节点：映像文件的节点号；</li></ol><ol id="782eb239-ed18-421c-9548-b8e7a7a1ef44" class="numbered-list" start="6"><li>路径: 映像文件的路径</li></ol></li></ol><ol id="0b37cb83-dbae-4fb1-8301-90382d23415d" class="numbered-list" start="2"><li>物理地址<ul id="716f9ec9-f9c4-4a57-9967-6bfe3c962233" class="bulleted-list"><li>也叫做内存地址，把内存分成很多个大小相等的存储单元，每个单元给一个编号，这个编号称为物理地址</li></ul><ul id="3230f210-f457-460a-b8d4-010468040f71" class="block-color-red bulleted-list"><li>物理地址可以<mark class="highlight-red">直接寻址</mark></li></ul></li></ol><ol id="3933bb69-26fa-4352-a806-6f376a4d0947" class="numbered-list" start="3"><li>地址绑定<figure id="2f23b725-65b5-4a08-b564-be44f58002d6" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%202.png"><img style="width:633px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%202.png"/></a></figure><p id="202b4eb5-c548-4047-ad7c-8c88a6cc2768" class="">一个用户程序的多步骤处理过程：</p><ul id="754f9254-c378-48c1-aff2-b97ba70ee244" class="bulleted-list"><li>编译器把<strong>符号地址（理解为逻辑地址）</strong>绑定在可重定位的地址</li></ul><ul id="c0d5bf99-5f12-4eae-9c17-4f42773c99ed" class="bulleted-list"><li>链接程序或者加载程序可以把可重定位地址绑定为绝对地址</li></ul><p id="7f00bf73-6f76-4d76-a2c3-bc0bd0ae4af6" class="">通常，将指令和数据绑定到内存地址，有以下三种情况</p><ol id="e51b5656-82eb-4f18-aa6c-ab88dcc57246" class="numbered-list" start="1"><li><strong>编译时</strong><mark class="highlight-red"><strong>（绝对代码，MS-DOS只有一个进程运行，不会发生冲突，所以编译的时候可以决定内存的地址）</strong></mark>
编译时就知道进程将内存中驻留地址</li></ol><ol id="8531676e-3d46-4c16-a075-e1376f172830" class="numbered-list" start="2"><li><strong>加载时</strong>
在编译时并不知道进程驻留内存地址，编译器必须生成可重定位代码。对于这种情况，最后绑定延迟到加载时才进行。</li></ol><ol id="814a4d70-380d-4501-b449-2fb9d4fd64b6" class="numbered-list" start="3"><li><strong>运行时</strong>
如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定必须延迟到执行时才进行，这需要特定的硬件支持(MMU)<figure id="8fdcbc67-c516-4190-987d-51be1b3e664b" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%203.png"><img style="width:812px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%203.png"/></a></figure><blockquote id="541118e0-b953-48d8-a9d9-877a57d09a1c" class="">对比：
编译（每次驻留<mark class="highlight-red">内存地址空间一样</mark>）
加载时（每次驻留<mark class="highlight-red">内存地址空间可能不一样</mark>）绑定，载入内存后<mark class="highlight-red">不可以发生地址变化</mark>
运行时绑定，载入内存后<mark class="highlight-red">可以发生地址变化</mark></blockquote><figure id="0f7712dd-be8b-46b8-bb34-03f87a087ee1" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%204.png"><img style="width:1347px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%204.png"/></a></figure></li></ol><p id="a8f986d3-6cb5-4547-9d3c-e567c7739f3b" class="">
</p></li></ol><h2 id="d5157d63-295b-4f83-8456-829e226298e3" class="">动态加载</h2><ol id="a5e39dab-c4c3-4afe-a2d6-51273658fc74" class="numbered-list" start="1"><li>直到被调用之前，程序不会被载入到内存，即加载延迟到运行时</li></ol><ol id="739f4815-c384-48fa-b0dd-37bc5f590c39" class="numbered-list" start="2"><li>优点<ul id="f5cc2f45-acab-466b-b2c3-77290e2cec77" class="bulleted-list"><li>内存使用率高：不使用的程序不会载入到内存</li></ul><ul id="a400aa1a-8679-4a45-80d3-d56512a43951" class="bulleted-list"><li>适合用户用大量代码来操作不常发生事件</li></ul><ul id="5802fbd3-4112-4f01-bc73-90cde55864ff" class="bulleted-list"><li>不需要操作系统的特别支持，由程序员来设计</li></ul></li></ol><h2 id="732ae4c1-5464-40f5-8cbe-6e08d12f55aa" class="">静态、动态链接</h2><ol id="08e7491a-98cc-4f89-b60b-bf72a583c281" class="numbered-list" start="1"><li>静态链接：加载程序合并到二进制程序镜像中，一直驻留在内存</li></ol><ol id="ea88bc2a-53b4-4a39-92e1-9d19eac71b65" class="numbered-list" start="2"><li>动态链接，链接延迟到运行时<p id="c2d30bd9-75f5-46c6-96fb-23b2d7245f87" class="">利用存根来定位适当的内存驻留库程序，如果该程序不在内存，存根首先检查所需子程序是否在内存中，如果不在，就将子程序装入内存。存根会用子程序地址来替换自己，并开始子程序</p></li></ol><ol id="84bfdf25-7f5c-4b5c-8736-a67b452f4651" class="numbered-list" start="3"><li>动态链接通常适用于系统库（如语言库），由操作系统管理</li></ol><ol id="74429860-e35d-4948-9e21-36833788cd1e" class="numbered-list" start="4"><li>动态链接和动态加载区别：加载程序员决定（程序方法控制加载），链接OS决定（程序启动时建立了链接，需要时载入内存）</li></ol><h2 id="776a3fcb-b132-49ed-a0af-39d9ef283444" class="">交换</h2><p id="528e86c6-0572-47ae-9a65-cf2017147a78" class="">进程可以暂时从内存中交换到备份存储上(通常是快速磁盘)，当需要再次执行时再调回到内存</p><ol id="5d73d1db-a714-4f3c-a441-110d2e61cea3" class="numbered-list" start="1"><li>优先级调度算法：低优先级交换出，高优先级交换进；滚出(roll out), 滚入(roll in)</li></ol><ol id="484d125f-475f-4b2a-9aee-d04b270f354b" class="numbered-list" start="2"><li>交换时间(转移时间)：转移时间与交换内存空间量成正比<figure id="f0a9bd78-99ad-47fc-bb0b-b1fafeec304d" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%205.png"><img style="width:480px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%205.png"/></a></figure><ul id="128c7b4c-b405-4472-99a4-94ef18c0fd7a" class="bulleted-list"><li>编译时绑定和加载时绑定：必须回到原位，运行时不可以发生地址变化</li></ul><ul id="ab2b13c0-573a-41f8-9821-69c363f6c112" class="bulleted-list"><li>执行时绑定运行时，可以发生地址变化</li></ul><p id="b0da5c7c-0efe-4a0d-b8af-d869fac89f79" class="">
</p></li></ol><h1 id="821ee9f8-5cc9-4621-a7f7-b3bc5ecf7c9d" class="">二、内存分配</h1><h2 id="6860b239-8ef8-4254-a3e4-8dbc087961cd" class="">连续分配</h2><ol id="5b679d6c-1473-423c-bf09-a0b4afcf969e" class="numbered-list" start="1"><li>多分区分配：多个固定大小分区（分区大小相同或者不同）</li></ol><ol id="165c6b13-9f7e-402e-b701-01d90aa4c77c" class="numbered-list" start="2"><li>可变分区分配：（整个内存空间是就是一个大孔, 操作系统用表来记录已用和未用内存）<figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="7879e388-a8f0-4d24-a430-eca9b3d383e8"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">系统需要用表来记录已分配孔和未分配孔的信息，方式有首次适应（第一个孔）、最佳适应（最小孔）、和最差适应（最大孔）</div></figure></li></ol><ol id="635f3917-33da-43f9-8f2d-d19e69948762" class="numbered-list" start="3"><li>碎片：外部碎片（所有分区之外的不连续片段碎片）、内部碎片（分区内分配后空余），解决方案为<mark class="highlight-red"><strong>紧缩</strong></mark>（移动内存内容，把所有的空闲空间合并成一整块）<figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="d79da4e1-f095-4621-92db-be5bf7a9b84f"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">紧缩只适用于动态重定位的时候，不适用于静态定位，但开销大</div></figure></li></ol><h2 id="c6fc27bf-e5da-48d9-9f08-d32a5b9d2dcc" class="">不连续分配</h2><ol id="b805c392-6a93-4ced-8a49-d896670de083" class="numbered-list" start="1"><li>分页（物理内存划分为帧，逻辑内存划分为页）页帧一一对应。为此需要掌握<strong>空闲帧信息</strong>以及<strong>页帧映射表（页表）</strong></li></ol><ol id="ae26d440-6899-45f9-a1d1-775f61cffef0" class="numbered-list" start="2"><li>逻辑地址分为页号（页表的索引对应帧）和页偏移<figure id="ae9bdaf3-f60a-4ef9-a304-53b580275878" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%206.png"><img style="width:480px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%206.png"/></a></figure><figure id="c0a6d7d0-6bbe-4a48-a6d8-3faf93a92feb" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%207.png"><img style="width:432px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%207.png"/></a></figure></li></ol><ol id="781da1f9-ca8e-45b2-bc33-2010329afc04" class="numbered-list" start="3"><li>页表实现：<ul id="87c510f1-7919-4ea5-9001-8f66b9440c26" class="block-color-red bulleted-list"><li><mark class="highlight-red">专用寄存器</mark>（贵且容量小）</li></ul><ul id="bf55a814-01f4-4211-8f79-986418a2f74e" class="bulleted-list"><li>放入<mark class="highlight-red">内存</mark>（页表基寄存器和页表长寄存器）出现<mark class="highlight-red">2次访问内存的缺陷</mark>（查页表和访问地址）解决方案TLB，类似cache<figure id="10689790-7fe8-4a48-a0fd-8a20be12dfe2" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%208.png"><img style="width:609px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%208.png"/></a></figure></li></ul></li></ol><ol id="f296ab9b-19dd-4c02-ac60-4cdb38c5f558" class="numbered-list" start="4"><li>分页环境下的内存保护：<p id="7c1fa5dd-8d0d-4ff2-964c-a9ca80e7ca09" class="">与每个帧关联一个的<mark class="highlight-red">保护位</mark>，建立与页表中的每一条目相关联的<mark class="highlight-red">有效位（相关的页在进程的逻辑地址空间内合法） 以及无效位</mark></p><p id="0c702a1e-ef6c-4fae-804d-d7ec6cb034ff" class="">例如，对于 14 位地址空间(0~16383)的系统，有一个程序，其有效地址空间为 0～10468。如果页的大小为 2KB，页 0、1、2、3、4 和 5 的地址可以通过页表正常映射。然而，如果试图产生页 6、7 中的地址，就会发现有效-无效位为无效，这样操作系统就会捕捉到这一非法操作(无效地址引用)。</p><figure id="c236d962-86bf-4468-bf7d-f950e4085bb0" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%209.png"><img style="width:528px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%209.png"/></a></figure></li></ol><ol id="fc0dcf51-a7e3-41bb-8abe-dc8c14a0c6f6" class="numbered-list" start="5"><li>分页的优点：<p id="c951842b-708e-4a22-b8d4-33c32216c9e7" class=""><mark class="highlight-red">通过共享页实现代码共享</mark>。进程的代码可分为可以共享的代码（每个进程共享代码段的(页)逻辑地址相同）和不可共享的代码（私有数据和代码，逻辑地址不同），可共享的代码通过共享页表的方式实现。</p><p id="23324faf-f956-4356-a8cc-1191df9492f2" class="">假设有个 40 个用户的系统，每个用户都执行一个文本编辑器。如果文本编辑器包括 150KB 的代码及 50KB 的数据空间，则需要 8000KB 来支持这 40 个用户。如果采用分页共享，则文本编辑器的纯代码可以在 40 个进程之间共享，每个进程都有它自己的数据页，此时仅需要 2150KB 空间。</p><figure id="f7817e98-35c9-4bc8-b6ea-c9fcf7246fbc" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2010.png"><img style="width:528px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2010.png"/></a></figure></li></ol><ol id="ef371e0c-5cbe-4e91-b256-472c680afb15" class="numbered-list" start="6"><li>页表结构：<p id="2f5999d9-39ef-4788-a517-6c06a85b1862" class="">把逻辑地址映射为物理地址的过程中，分页方式需要系统维护页表信息。实现页表的方式主要有以下几种：</p><ul id="788580aa-5327-4cbc-b393-2ba59bdbd71d" class="toggle"><li><details open=""><summary>层次页表：把逻辑地址编址设为多层次，即多层次的页表。</summary><figure id="69eddddd-f2a3-4ac0-a0b7-a11a973809fe" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2011.png"><img style="width:528px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2011.png"/></a></figure><figure id="0fac5da6-a3a5-41df-b92c-704e99871d6a" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2012.png"><img style="width:432px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2012.png"/></a></figure><p id="28326987-2f76-4eed-94df-b0bd144cc7b5" class=""><mark class="highlight-red">可以实现不连续存储，节约内存空间</mark></p><figure id="401b50b6-04a5-4b16-b37e-b1b6c009fcd6" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2013.png"><img style="width:432px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2013.png"/></a></figure><p id="05bf5e5f-8d58-413b-a433-1930ad06a9dd" class="">单层情况</p><figure id="5a1b6c3c-db0f-4e41-8e55-58a4d219fef7" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2014.png"><img style="width:576px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2014.png"/></a></figure><p id="e259de77-7100-414f-b956-ea626ae7d0fe" class="">双层情况</p><figure id="dcc40f94-2b5c-47fc-a8d3-0e370e00aa2f" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2015.png"><img style="width:1307px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2015.png"/></a></figure></details></li></ul><ul id="61ed1ed9-39f4-4c92-a116-f8f10fa714d1" class="toggle"><li><details open=""><summary>哈希页表：</summary><p id="3c514df9-8e6a-421d-a773-4b0bb7e333e6" class="">处理超过32位地址空间的常用方法。逻辑地址=虚拟页码（hashcode）+偏移量。哈希页表的每一条目是链表，链表的每个元素包括（虚拟页码，所映射的帧号，下一个元素指针）根据虚拟页码（哈希值）找到匹配的条目，并在链表里找到相对应的帧号</p><figure id="6d42e4b3-6b9f-4a4e-b734-2cc876a357a9" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2016.png"><img style="width:528px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2016.png"/></a></figure></details></li></ul><ul id="e15ab54c-9c7a-48eb-9c9e-88c4ab0f175a" class="toggle"><li><details open=""><summary>反向页表：为了减少页表消耗的内存空间而采用的方法。整个系统只有一个页表，页表对于每个真正的内存页或帧才建立一个条目。反向页表编址（PID,页码,页偏移）</summary><ul id="f78a7b73-e6cf-4b10-be96-c6d99ce8df2a" class="bulleted-list"><li>地址信息：需要用页码和页偏移来确定空间</li></ul><ul id="cad79a50-3424-4f08-9301-8fd0e81aba10" class="bulleted-list"><li>进程信息：需要用进程标识符确定进程信息<figure id="f2a7aeca-3aca-45b6-867f-2272eec7ad98" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2017.png"><img style="width:646px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2017.png"/></a></figure></li></ul></details></li></ul></li></ol><h2 id="2014cb22-ffa1-4ed4-8c03-60970f51f8e2" class="">分段方式</h2><p id="dc51ec79-9650-4061-9c7e-6af6d2a8ed0e" class="">以用户视角去管理内存的方式，一个程序由多个逻辑段组成：
<mark class="highlight-red">一般组成：主程序、函数、方法、对象、堆、栈、局部变量、全局变量等</mark></p><ol id="8f0eadb5-5fe8-44e7-b474-d7667b4aa2b9" class="numbered-list" start="1"><li>逻辑地址=分段号+偏移</li></ol><ol id="26da5498-a16b-4134-b9d1-c3c68bbe7eeb" class="numbered-list" start="2"><li>段表=段界限地址+段基地址</li></ol><ol id="db2b3d2d-d354-47a6-969c-ad494c1415f7" class="numbered-list" start="3"><li>硬件<figure id="7f05db22-8a24-4c33-89a1-80784a4e045f" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2018.png"><img style="width:526px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2018.png"/></a></figure><figure id="de6eb236-52af-4f5c-aee2-1b136245f2ca" class="image"><a href="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2019.png"><img style="width:621px" src="Untitled%201de92790cc13494e8177f15a70fe3dbe/Untitled%2019.png"/></a></figure></li></ol><ol id="043a7d33-073d-491e-8916-3663a3dcdefd" class="numbered-list" start="4"><li>段必须连续分配，所以会产生<mark class="highlight-red">碎片</mark>问题</li></ol><ol id="c7bd0c53-5a45-4261-a28c-9bc94850481e" class="numbered-list" start="5"><li>分段最后映射到物理地址加的是段界限（偏移），其逻辑地址的偏移是其在段内的偏移。<mark class="highlight-red">除了分段的所有结构最后映射到物理地址加的都是逻辑地址的那个偏移量。</mark></li></ol><ol id="7de50e4b-2967-4114-a88a-b3da7e3d4d1a" class="numbered-list" start="6"><li>分段的段表是先界限地址后段基地址，其他的都是先基地址后偏移量。</li></ol><p id="4d39e233-62fd-4123-9ff9-35c961ad84d2" class="">
</p></div></article></body></html>